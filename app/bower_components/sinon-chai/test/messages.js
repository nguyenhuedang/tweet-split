"use strict";var sinon=require("sinon"),expect=require("chai").expect,swallow=require("./common").swallow;describe("Messages",function(){describe("about call count",function(){it("should be correct for the base cases",function(){var a=sinon.spy();expect(function(){a.should.have.been.called}).to.throw("expected spy to have been called at least once, but it was never called"),expect(function(){a.should.have.been.calledOnce}).to.throw("expected spy to have been called exactly once, but it was called 0 times"),expect(function(){a.should.have.been.calledTwice}).to.throw("expected spy to have been called exactly twice, but it was called 0 times"),expect(function(){a.should.have.been.calledThrice}).to.throw("expected spy to have been called exactly thrice, but it was called 0 times"),expect(function(){a.should.have.callCount(1)}).to.throw("expected spy to have been called exactly once, but it was called 0 times"),expect(function(){a.should.have.callCount(4)}).to.throw("expected spy to have been called exactly 4 times, but it was called 0 times")}),it("should be correct for the negated cases",function(){var a=sinon.spy(),b=sinon.spy(),c=sinon.spy(),d=sinon.spy();a(),b(),b(),c(),c(),c(),d(),d(),d(),d(),expect(function(){a.should.not.have.been.called}).to.throw("expected spy to not have been called"),expect(function(){a.should.not.have.been.calledOnce}).to.throw("expected spy to not have been called exactly once"),expect(function(){b.should.not.have.been.calledTwice}).to.throw("expected spy to not have been called exactly twice"),expect(function(){c.should.not.have.been.calledThrice}).to.throw("expected spy to not have been called exactly thrice"),expect(function(){a.should.not.have.callCount(1)}).to.throw("expected spy to not have been called exactly once"),expect(function(){d.should.not.have.callCount(4)}).to.throw("expected spy to not have been called exactly 4 times")})}),describe("about call order",function(){it("should be correct for the base cases",function(){var a=sinon.spy(),b=sinon.spy();a.displayName="spyA",b.displayName="spyB",expect(function(){a.should.have.been.calledBefore(b)}).to.throw("expected spyA to have been called before function spyB() {}"),a.calledImmediatelyBefore&&expect(function(){a.should.have.been.calledImmediatelyBefore(b)}).to.throw("expected spyA to have been called immediately before function spyB() {}"),expect(function(){b.should.have.been.calledAfter(a)}).to.throw("expected spyB to have been called after function spyA() {}"),b.calledImmediatelyAfter&&expect(function(){b.should.have.been.calledImmediatelyAfter(a)}).to.throw("expected spyB to have been called immediately after function spyA() {}")}),it("should be correct for the negated cases",function(){var a=sinon.spy(),b=sinon.spy();a.displayName="spyA",b.displayName="spyB",a(),b(),expect(function(){a.should.not.have.been.calledBefore(b)}).to.throw("expected spyA to not have been called before function spyB() {}"),a.calledImmediatelyBefore&&expect(function(){a.should.not.have.been.calledImmediatelyBefore(b)}).to.throw("expected spyA to not have been called immediately before function spyB() {}"),expect(function(){b.should.not.have.been.calledAfter(a)}).to.throw("expected spyB to not have been called after function spyA() {}"),b.calledImmediatelyAfter&&expect(function(){b.should.not.have.been.calledImmediatelyAfter(a)}).to.throw("expected spyB to not have been called immediately after function spyA() {}")})}),describe("about call context",function(){it("should be correct for the basic case",function(){var a=sinon.spy(),b={};a.call({x:"y"});var d="expected spy to have been called with {  } as this, but it was called with "+a.printf("%t")+" instead";expect(function(){a.should.have.been.calledOn(b)}).to.throw(d),expect(function(){a.getCall(0).should.have.been.calledOn(b)}).to.throw(d)}),it("should be correct for the negated case",function(){var a=sinon.spy(),b={};a.call(b);var c="expected spy to not have been called with {  } as this";expect(function(){a.should.not.have.been.calledOn(b)}).to.throw(c),expect(function(){a.getCall(0).should.not.have.been.calledOn(b)}).to.throw(c)}),it("should be correct for the always case",function(){var a=sinon.spy(),b={};a.call({x:"y"});var d="expected spy to always have been called with {  } as this, but it was called with "+a.printf("%t")+" instead";expect(function(){a.should.always.have.been.calledOn(b)}).to.throw(d)})}),describe("about calling with new",function(){it("should be correct for the basic case",function(){var a=sinon.spy();a();var b="expected spy to have been called with new";expect(function(){a.should.have.been.calledWithNew}).to.throw(b),expect(function(){a.getCall(0).should.have.been.calledWithNew}).to.throw(b)}),it("should be correct for the negated case",function(){var a=sinon.spy();new a;var b="expected spy to not have been called with new";expect(function(){a.should.not.have.been.calledWithNew}).to.throw(b),expect(function(){a.getCall(0).should.not.have.been.calledWithNew}).to.throw(b)}),it("should be correct for the always case",function(){var a=sinon.spy();new a,a();expect(function(){a.should.always.have.been.calledWithNew}).to.throw("expected spy to always have been called with new")})}),describe("about call arguments",function(){it("should be correct for the basic cases",function(){var a=sinon.spy();a(1,2,3),expect(function(){a.should.have.been.calledWith("a","b","c")}).to.throw("expected spy to have been called with arguments a, b, c\n    spy(1, 2, 3)"),expect(function(){a.should.have.been.calledWithExactly("a","b","c")}).to.throw("expected spy to have been called with exact arguments a, b, c\n    spy(1, 2, 3)"),expect(function(){a.should.have.been.calledWithMatch(sinon.match("foo"))}).to.throw("expected spy to have been called with arguments matching match(\"foo\")\n    spy(1, 2, 3)"),expect(function(){a.getCall(0).should.have.been.calledWith("a","b","c")}).to.throw("expected spy to have been called with arguments a, b, c\n    spy(1, 2, 3)"),expect(function(){a.getCall(0).should.have.been.calledWithExactly("a","b","c")}).to.throw("expected spy to have been called with exact arguments a, b, c\n    spy(1, 2, 3)"),expect(function(){a.getCall(0).should.have.been.calledWithMatch(sinon.match("foo"))}).to.throw("expected spy to have been called with arguments matching match(\"foo\")\n    spy(1, 2, 3)")}),it("should be correct for the negated cases",function(){var a=sinon.spy();a(1,2,3),expect(function(){a.should.not.have.been.calledWith(1,2,3)}).to.throw("expected spy to not have been called with arguments 1, 2, 3"),expect(function(){a.should.not.have.been.calledWithExactly(1,2,3)}).to.throw("expected spy to not have been called with exact arguments 1, 2, 3"),expect(function(){a.should.not.have.been.calledWithMatch(sinon.match(1))}).to.throw("expected spy to not have been called with arguments matching match(1)"),expect(function(){a.getCall(0).should.not.have.been.calledWith(1,2,3)}).to.throw("expected spy to not have been called with arguments 1, 2, 3"),expect(function(){a.getCall(0).should.not.have.been.calledWithExactly(1,2,3)}).to.throw("expected spy to not have been called with exact arguments 1, 2, 3"),expect(function(){a.getCall(0).should.not.have.been.calledWithMatch(sinon.match(1))}).to.throw("expected spy to not have been called with arguments matching match(1)")}),it("should be correct for the always cases",function(){var a=sinon.spy();a(1,2,3),a("a","b","c");var b=/expected spy to always have been called with arguments 1, 2, 3/;expect(function(){a.should.always.have.been.calledWith(1,2,3)}).to.throw(b);var c=/expected spy to always have been called with exact arguments 1, 2, 3/;expect(function(){a.should.always.have.been.calledWithExactly(1,2,3)}).to.throw(c);var d=/expected spy to always have been called with arguments matching match\(1\)/;expect(function(){a.should.always.have.been.calledWithMatch(sinon.match(1))}).to.throw(d)})}),describe("about returning",function(){it("should be correct for the basic case",function(){var a=sinon.spy.create(function(){return 1});a(),expect(function(){a.should.have.returned(2)}).to.throw("expected spy to have returned 2"),expect(function(){a.getCall(0).should.have.returned(2)}).to.throw("expected spy to have returned 2")}),it("should be correct for the negated case",function(){var a=sinon.spy.create(function(){return 1});a(),expect(function(){a.should.not.have.returned(1)}).to.throw("expected spy to not have returned 1"),expect(function(){a.getCall(0).should.not.have.returned(1)}).to.throw("expected spy to not have returned 1")}),it("should be correct for the always case",function(){var a=sinon.spy.create(function(){return 1});a(),expect(function(){a.should.always.have.returned(2)}).to.throw("expected spy to always have returned 2")})}),describe("about throwing",function(){it("should be correct for the basic cases",function(){var a=sinon.spy(),b=sinon.spy.create(function(){throw new Error});a(),swallow(b),expect(function(){a.should.have.thrown()}).to.throw("expected spy to have thrown"),expect(function(){a.getCall(0).should.have.thrown()}).to.throw("expected spy to have thrown"),expect(function(){b.should.have.thrown("TypeError")}).to.throw("expected spy to have thrown TypeError"),expect(function(){b.getCall(0).should.have.thrown("TypeError")}).to.throw("expected spy to have thrown TypeError"),expect(function(){b.should.have.thrown({message:"x"})}).to.throw("expected spy to have thrown { message: \"x\" }"),expect(function(){b.getCall(0).should.have.thrown({message:"x"})}).to.throw("expected spy to have thrown { message: \"x\" }")}),it("should be correct for the negated cases",function(){var a=new Error("boo!"),b=sinon.spy.create(function(){throw a});swallow(b),expect(function(){b.should.not.have.thrown()}).to.throw("expected spy to not have thrown"),expect(function(){b.getCall(0).should.not.have.thrown()}).to.throw("expected spy to not have thrown"),expect(function(){b.should.not.have.thrown("Error")}).to.throw("expected spy to not have thrown Error"),expect(function(){b.getCall(0).should.not.have.thrown("Error")}).to.throw("expected spy to not have thrown Error"),expect(function(){b.should.not.have.thrown(a)}).to.throw("expected spy to not have thrown Error: boo!"),expect(function(){b.getCall(0).should.not.have.thrown(a)}).to.throw("expected spy to not have thrown Error: boo!")}),it("should be correct for the always cases",function(){var a=sinon.spy(),b=sinon.spy.create(function(){throw new Error});a(),swallow(b),expect(function(){a.should.have.always.thrown()}).to.throw("expected spy to always have thrown"),expect(function(){b.should.have.always.thrown("TypeError")}).to.throw("expected spy to always have thrown TypeError"),expect(function(){b.should.have.always.thrown({message:"x"})}).to.throw("expected spy to always have thrown { message: \"x\" }")})}),describe("when used on a non-spy/non-call",function(){function a(){}it("should be informative for properties",function(){expect(function(){a.should.have.been.called}).to.throw(TypeError,/not a spy/)}),it("should be informative for methods",function(){expect(function(){a.should.have.been.calledWith("foo")}).to.throw(TypeError,/not a spy/)})}),it("should not trigger getters for passing assertions",function(){var a={},b=!1;Object.defineProperty(a,"getter",{get:function(){b=!0},enumerable:!0});var c=sinon.spy();c(a),c.should.have.been.calledWith(a),expect(b).to.be.false})});
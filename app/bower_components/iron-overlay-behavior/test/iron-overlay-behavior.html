<!DOCTYPE html><html><head><title>iron-overlay-behavior tests</title><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,user-scalable=yes">
    <script>if (!window.customElements) { document.write('<!--'); }</script>
    <script type="text/javascript" src="../../webcomponentsjs/custom-elements-es5-adapter.js"></script>
    <!--! do not remove -->
<script src="../../webcomponentsjs/webcomponents-lite.js"></script><script src="../../web-component-tester/browser.js"></script><link rel="import" href="../../iron-test-helpers/iron-test-helpers.html"><link rel="import" href="test-overlay.html"><link rel="import" href="test-overlay2.html"><link rel="import" href="test-buttons.html"><link rel="import" href="test-menu-button.html"></head><body><custom-style><style is="custom-style">iron-overlay-backdrop{--iron-overlay-backdrop:{transition:none;-webkit-transition:none;};}</style></custom-style><test-fixture id="basic"><template><test-overlay>Basic Overlay</test-overlay></template></test-fixture><test-fixture id="opened"><template><test-overlay opened="">Basic Overlay</test-overlay></template></test-fixture><test-fixture id="autofocus"><template><test-overlay>Autofocus <button autofocus="">button</button></test-overlay></template></test-fixture><test-fixture id="focusables"><template><test-overlay tabindex="-1"><h2>Focusables (no tabindex)</h2><div><input class="focusable1" placeholder="1 (nested)"></div><button class="focusable2">1</button> <button disabled="">disabled button</button><div tabindex="-1">not focusable</div><button class="focusable3">2</button></test-overlay><test-overlay tabindex="-1"><h2>Focusables (with tabindex)</h2><div tabindex="-1">not focusable</div><div tabindex="3" class="focusable3">3</div><div tabindex="4" class="focusable4">4</div><div tabindex="5" class="focusable5">5</div><div><div tabindex="1" class="focusable1">1 (nested)</div><div tabindex="6" class="focusable6">6 (nested)</div></div><div tabindex="2" class="focusable2">2</div></test-overlay><test-overlay2>Overlay with optimized focusableNodes getter <button class="focusable1">1</button></test-overlay2></template></test-fixture><test-fixture id="backdrop"><template><test-overlay with-backdrop="">Overlay with backdrop</test-overlay></template></test-fixture><test-fixture id="multiple"><template><test-overlay class="overlay-1">Test overlay 1</test-overlay><test-overlay class="overlay-2">Test overlay 2 <button>Click</button></test-overlay><test-overlay2 class="overlay-3">Other overlay 3</test-overlay2></template></test-fixture><test-fixture id="composed"><template><test-menu-button></test-menu-button></template></test-fixture><test-buttons id="buttons"></test-buttons><input id="focusInput" placeholder="focus input"><script>function runAfterOpen(a,b){a.addEventListener('iron-overlay-opened',b),a.open()}function runAfterClose(a,b){a.addEventListener('iron-overlay-closed',b),a.close()}suite('basic overlay',function(){var a;setup(function(){a=fixture('basic')}),test('overlay starts hidden',function(){assert.isFalse(a.opened,'overlay starts closed'),assert.equal(getComputedStyle(a).display,'none','overlay starts hidden')}),test('_renderOpened called only after is attached',function(b){var c=document.createElement('test-overlay'),d=sinon.spy(c,'_renderOpened');c.opened=!0,c.async(function(){assert.isFalse(d.called,'_renderOpened not called'),assert.isNotOk(c._manager.currentOverlay(),'currentOverlay not set'),b()},100)}),test('overlay open/close events',function(b){var c=0;a.addEventListener('iron-overlay-opened',function(){c+=1,a.opened=!1}),a.addEventListener('iron-overlay-closed',function(){c+=1,assert.equal(c,2,'opened and closed events fired'),b()}),a.opened=!0}),test('open() refits overlay only once',function(b){var c=sinon.spy(a,'refit');runAfterOpen(a,function(){assert.equal(c.callCount,1,'overlay did refit only once'),b()})}),test('open overlay refits on iron-resize',function(b){runAfterOpen(a,function(){var c=sinon.spy(a,'refit');a.fire('iron-resize'),Polymer.RenderStatus.afterNextRender(a,function(){assert.isTrue(c.called,'overlay did refit'),b()})})}),test('closed overlay does not refit on iron-resize',function(b){var c=sinon.spy(a,'refit');a.fire('iron-resize'),Polymer.RenderStatus.afterNextRender(a,function(){assert.isFalse(c.called,'overlay should not refit'),b()})}),test('open() triggers iron-resize',function(b){var c=0;window.addEventListener('resize',function(){c--},!0),a.addEventListener('iron-resize',function(){c++}),runAfterOpen(a,function(){assert.equal(c,1,'iron-resize called once before iron-overlay-opened'),b()})}),test('close() triggers iron-resize',function(b){runAfterOpen(a,function(){var c=sinon.stub();a.addEventListener('iron-resize',c),runAfterClose(a,function(){assert.equal(c.callCount,1,'iron-resize called once before iron-overlay-closed'),b()})})}),test('closed overlay does not trigger iron-resize when its content changes',function(b){var c=0;window.addEventListener('resize',function(){c--},!0),a.addEventListener('iron-resize',function(){c++}),Polymer.dom(a).appendChild(document.createElement('div')),Polymer.RenderStatus.afterNextRender(a,function(){assert.equal(c,0,'iron-resize should not be called'),b()})}),test('open overlay triggers iron-resize when its content changes',function(b){runAfterOpen(a,function(){var c=sinon.stub();a.addEventListener('iron-resize',c),Polymer.dom(a).appendChild(document.createElement('div')),Polymer.RenderStatus.afterNextRender(a,function(){assert.equal(c.callCount,1,'iron-resize should be called once'),b()})})}),test('close an overlay quickly after open',function(b){a.open(),a.async(function(){this.close(),this.async(function(){b()},300)})}),test('clicking an overlay does not close it',function(b){runAfterOpen(a,function(){var c=sinon.stub();a.addEventListener('iron-overlay-closed',c),MockInteractions.tap(a),a.async(function(){assert.isFalse(c.called,'iron-overlay-closed should not fire'),b()},10)})}),test('open overlay on mousedown does not close it',function(b){var c=document.createElement('button');c.addEventListener('mousedown',a.open.bind(a)),document.body.appendChild(c),MockInteractions.tap(c),document.body.removeChild(c),assert.isTrue(a.opened,'overlay opened'),a.async(function(){assert.isTrue(a.opened,'overlay is still open'),b()},10)}),test('clicking outside fires iron-overlay-canceled',function(b){runAfterOpen(a,function(){a.addEventListener('iron-overlay-canceled',function(c){assert.equal(c.detail.target,document.body,'detail contains original click event'),b()}),MockInteractions.tap(document.body)})}),test('clicking outside closes the overlay',function(b){runAfterOpen(a,function(){a.addEventListener('iron-overlay-closed',function(c){assert.isTrue(c.detail.canceled,'overlay is canceled'),b()}),MockInteractions.tap(document.body)})}),test('iron-overlay-canceled event can be prevented',function(b){runAfterOpen(a,function(){a.addEventListener('iron-overlay-canceled',function(d){d.preventDefault()});var c=sinon.stub();a.addEventListener('iron-overlay-closed',c),MockInteractions.tap(document.body),Polymer.Base.async(function(){assert.isTrue(a.opened,'overlay is still open'),assert.isFalse(c.called,'iron-overlay-closed not fired'),b()},10)})}),test('cancel an overlay with esc key',function(b){runAfterOpen(a,function(){a.addEventListener('iron-overlay-canceled',function(c){assert.equal(c.detail.type,'keydown'),b()}),MockInteractions.pressAndReleaseKeyOn(document,27)})}),test('close an overlay with esc key',function(b){runAfterOpen(a,function(){a.addEventListener('iron-overlay-closed',function(c){assert.isTrue(c.detail.canceled,'overlay is canceled'),b()}),MockInteractions.pressAndReleaseKeyOn(document,27)})}),test('no-cancel-on-outside-click property',function(b){a.noCancelOnOutsideClick=!0,runAfterOpen(a,function(){var c=sinon.stub();a.addEventListener('iron-overlay-closed',c),MockInteractions.tap(document.body),Polymer.Base.async(function(){assert.isFalse(c.called,'iron-overlay-closed should not fire'),b()},10)})}),test('no-cancel-on-esc-key property',function(b){a.noCancelOnEscKey=!0,runAfterOpen(a,function(){var c=sinon.stub();a.addEventListener('iron-overlay-closed',c),MockInteractions.pressAndReleaseKeyOn(document,27),Polymer.Base.async(function(){assert.isFalse(c.called,'iron-overlay-cancel should not fire'),b()},10)})}),test('with-backdrop sets tabindex=-1 and removes it',function(){a.withBackdrop=!0,assert.equal(a.getAttribute('tabindex'),'-1','tabindex is -1'),a.withBackdrop=!1,assert.isFalse(a.hasAttribute('tabindex'),'tabindex removed')}),test('with-backdrop does not override tabindex if already set',function(){a.setAttribute('tabindex','1'),a.withBackdrop=!0,assert.equal(a.getAttribute('tabindex'),'1','tabindex is 1'),a.withBackdrop=!1,assert.equal(a.getAttribute('tabindex'),'1','tabindex is still 1')})}),suite('keyboard event listener',function(){var a,b=function(d){d.preventDefault(),d.stopPropagation()};suiteSetup(function(){document.addEventListener('keydown',b,!0)}),setup(function(){a=fixture('basic')}),suiteTeardown(function(){document.removeEventListener('keydown',b,!0)}),test('cancel an overlay with esc key even if event is prevented by other listeners',function(c){runAfterOpen(a,function(){a.addEventListener('iron-overlay-canceled',function(){c()}),MockInteractions.pressAndReleaseKeyOn(document,27)})})}),suite('tap event listener',function(){var a,b=function(d){d.preventDefault(),d.stopPropagation()};suiteSetup(function(){document.body.addEventListener('tap',b,!0)}),setup(function(){a=fixture('basic')}),suiteTeardown(function(){document.body.removeEventListener('tap',b,!0)}),test('cancel an overlay with tap outside even if event is prevented by other listeners',function(c){runAfterOpen(a,function(){a.addEventListener('iron-overlay-canceled',function(){c()}),MockInteractions.tap(document.body)})})}),suite('opened overlay',function(){var a;setup(function(){a=fixture('opened')}),test('overlay open by default',function(b){a.addEventListener('iron-overlay-opened',function(){assert.isTrue(a.opened,'overlay starts opened'),assert.notEqual(getComputedStyle(a).display,'none','overlay starts showing'),b()})}),test('overlay positioned & sized properly',function(b){a.addEventListener('iron-overlay-opened',function(){var c=getComputedStyle(a);assert.closeTo(parseFloat(c.left),(window.innerWidth-a.offsetWidth)/2,1,'centered horizontally'),assert.closeTo(parseFloat(c.top),(window.innerHeight-a.offsetHeight)/2,1,'centered vertically'),b()})})}),suite('focus handling',function(){var a;setup(function(){document.body.focus(),a=fixture('autofocus')}),test('node with autofocus is focused',function(b){runAfterOpen(a,function(){assert.equal(Polymer.dom(a).querySelector('[autofocus]'),document.activeElement,'<button autofocus> is focused'),b()})}),test('no-auto-focus will not focus node with autofocus',function(b){a.noAutoFocus=!0,runAfterOpen(a,function(){assert.notEqual(Polymer.dom(a).querySelector('[autofocus]'),document.activeElement,'<button autofocus> not focused after opened'),b()}),assert.notEqual(Polymer.dom(a).querySelector('[autofocus]'),document.activeElement,'<button autofocus> not immediately focused')}),test('no-cancel-on-outside-click property; focus stays on overlay when click outside',function(b){a.noCancelOnOutsideClick=!0,runAfterOpen(a,function(){MockInteractions.tap(document.body),Polymer.Base.async(function(){assert.equal(Polymer.dom(a).querySelector('[autofocus]'),document.activeElement,'<button autofocus> is focused'),b()},10)})}),test('with-backdrop traps the focus within the overlay',function(b){var c=sinon.stub(),d=document.createElement('button');document.body.appendChild(d),d.addEventListener('focus',c,!0),a.withBackdrop=!0,runAfterOpen(a,function(){MockInteractions.focus(d),assert.equal(Polymer.dom(a).querySelector('[autofocus]'),document.activeElement,'<button autofocus> is focused'),assert.equal(c.callCount,0,'button in body did not get the focus'),document.body.removeChild(d),b()})}),test('overlay with-backdrop and 1 focusable: prevent TAB and trap the focus',function(b){a.withBackdrop=!0,runAfterOpen(a,function(){Polymer.Base.async(function(){var c=sinon.spy();document.addEventListener('keydown',c),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(Polymer.dom(a).querySelector('[autofocus]'),document.activeElement,'focus stays on button'),assert.isTrue(c.calledOnce,'keydown spy called'),assert.isTrue(c.getCall(0).args[0].defaultPrevented,'keydown default prevented'),document.removeEventListener('keydown',c),b()},1)})}),test('empty overlay with-backdrop: prevent TAB and trap the focus',function(b){a=fixture('basic'),a.withBackdrop=!0,runAfterOpen(a,function(){Polymer.Base.async(function(){var c=sinon.spy();document.addEventListener('keydown',c),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(a,document.activeElement,'focus stays on overlay'),assert.isTrue(c.calledOnce,'keydown spy called'),assert.isTrue(c.getCall(0).args[0].defaultPrevented,'keydown default prevented'),document.removeEventListener('keydown',c),b()},1)})})}),suite('focusable nodes',function(){var a,b,c;setup(function(){var d=fixture('focusables');a=d[0],b=d[1],c=d[2]}),test('_focusableNodes returns nodes that are focusable',function(d){runAfterOpen(a,function(){var e=a._focusableNodes;assert.equal(e.length,3,'3 nodes are focusable'),assert.equal(e[0],Polymer.dom(a).querySelector('.focusable1')),assert.equal(e[1],Polymer.dom(a).querySelector('.focusable2')),assert.equal(e[2],Polymer.dom(a).querySelector('.focusable3')),d()})}),test('_focusableNodes includes overlay if it has a valid tabindex',function(d){runAfterOpen(a,function(){a.setAttribute('tabindex','0');var e=a._focusableNodes;assert.equal(e.length,4,'4 focusable nodes'),assert.notEqual(e.indexOf(a),-1,'overlay is included'),d()})}),test('_focusableNodes respects the tabindex order',function(d){runAfterOpen(b,function(){var e=b._focusableNodes;assert.equal(e.length,6,'6 nodes are focusable'),assert.equal(e[0],Polymer.dom(b).querySelector('.focusable1')),assert.equal(e[1],Polymer.dom(b).querySelector('.focusable2')),assert.equal(e[2],Polymer.dom(b).querySelector('.focusable3')),assert.equal(e[3],Polymer.dom(b).querySelector('.focusable4')),assert.equal(e[4],Polymer.dom(b).querySelector('.focusable5')),assert.equal(e[5],Polymer.dom(b).querySelector('.focusable6')),d()})}),test('_focusableNodes can be overridden',function(d){runAfterOpen(c,function(){var e=c._focusableNodes;assert.equal(e.length,2,'length ok'),assert.equal(e[0],c.$.first,'first ok'),assert.equal(e[1],c.$.last,'last ok'),d()})}),test('with-backdrop: TAB & Shift+TAB wrap focus',function(d){a.withBackdrop=!0,runAfterOpen(a,function(){var e=a._focusableNodes;Polymer.Base.async(function(){e[e.length-1].focus();var g=sinon.spy();document.addEventListener('keydown',g),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(e[0],document.activeElement,'focus wrapped to first focusable'),assert.isTrue(g.calledOnce,'keydown spy called'),assert.isTrue(g.getCall(0).args[0].defaultPrevented,'keydown default prevented'),MockInteractions.pressAndReleaseKeyOn(document,9,['shift']),assert.equal(e[e.length-1],document.activeElement,'focus wrapped to last focusable'),assert.isTrue(g.calledTwice,'keydown spy called again'),assert.isTrue(g.getCall(1).args[0].defaultPrevented,'keydown default prevented again'),document.removeEventListener('keydown',g),d()},1)})}),test('with-backdrop: TAB & Shift+TAB wrap focus respecting tabindex',function(d){b.withBackdrop=!0,runAfterOpen(b,function(){var e=b._focusableNodes;Polymer.Base.async(function(){e[e.length-1].focus(),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(e[0],document.activeElement,'focus wrapped to first focusable'),MockInteractions.pressAndReleaseKeyOn(document,9,['shift']),assert.equal(e[e.length-1],document.activeElement,'focus wrapped to last focusable'),d()},1)})}),test('with-backdrop: Shift+TAB after open wrap focus',function(d){a.withBackdrop=!0,runAfterOpen(a,function(){var e=a._focusableNodes;Polymer.Base.async(function(){var g=sinon.spy();document.addEventListener('keydown',g),MockInteractions.pressAndReleaseKeyOn(document,9,['shift']),assert.equal(e[e.length-1],document.activeElement,'focus wrapped to last focusable'),assert.isTrue(g.calledOnce,'keydown spy called'),assert.isTrue(g.getCall(0).args[0].defaultPrevented,'keydown default prevented'),document.removeEventListener('keydown',g),d()},1)})}),test('with-backdrop: after open, update last focusable node and then Shift+TAB',function(d){a.withBackdrop=!0,runAfterOpen(a,function(){var e=a._focusableNodes;Polymer.Base.async(function(){e[e.length-1].setAttribute('tabindex','-1'),a.invalidateTabbables(),MockInteractions.pressAndReleaseKeyOn(document,9,['shift']),assert.equal(e[e.length-2],document.activeElement,'focus wrapped correctly'),d()},1)})}),test('with-backdrop: Shift+TAB wrap focus in shadowDOM',function(d){c.withBackdrop=!0,runAfterOpen(c,function(){Polymer.Base.async(function(){var e=sinon.spy();document.addEventListener('keydown',e),MockInteractions.pressAndReleaseKeyOn(document,9,['shift']),assert.equal(c.$.last,Polymer.IronOverlayManager.deepActiveElement,'focus wrapped to last focusable in the shadowDOM'),assert.isTrue(e.calledOnce,'keydown spy called'),assert.isTrue(e.getCall(0).args[0].defaultPrevented,'keydown default prevented'),document.removeEventListener('keydown',e),d()},1)})})}),suite('Polymer.IronOverlayManager.deepActiveElement',function(){test('handles document.body',function(){document.body.focus(),assert.equal(Polymer.IronOverlayManager.deepActiveElement,document.body)}),test('handles light dom',function(){var a=document.getElementById('focusInput');a.focus(),assert.equal(Polymer.IronOverlayManager.deepActiveElement,a,'input is handled'),a.blur()}),test('handles shadow dom',function(){var a=document.getElementById('buttons').$.button0;a.focus(),assert.equal(Polymer.IronOverlayManager.deepActiveElement,a),a.blur()})}),suite('restore-focus-on-close',function(){var a;setup(function(){a=fixture('autofocus'),a.restoreFocusOnClose=!0}),teardown(function(){document.body.focus()}),test('does not return focus on close by default (restore-focus-on-close=false)',function(b){a.restoreFocusOnClose=!1;var c=document.getElementById('focusInput');c.focus(),runAfterOpen(a,function(){runAfterClose(a,function(){assert.notEqual(Polymer.IronOverlayManager.deepActiveElement,c,'focus is not restored to focusable'),b()})})}),test('overlay returns focus on close',function(b){var c=document.getElementById('focusInput');c.focus(),runAfterOpen(a,function(){runAfterClose(a,function(){assert.equal(Polymer.IronOverlayManager.deepActiveElement,c,'focus restored to focusable'),b()})})}),test('overlay returns focus on close (ShadowDOM)',function(b){var c=document.getElementById('buttons').$.button0;c.focus(),runAfterOpen(a,function(){runAfterClose(a,function(){assert.equal(Polymer.IronOverlayManager.deepActiveElement,c,'focus restored to focusable'),b()})})})}),suite('overlay with backdrop',function(){var a;setup(function(){a=fixture('backdrop')}),test('backdrop is opened when overlay is opened',function(b){assert.isOk(a.backdropElement,'backdrop is defined'),runAfterOpen(a,function(){assert.isTrue(a.backdropElement.opened,'backdrop is opened'),assert.isOk(a.backdropElement.parentNode,'backdrop is inserted in the DOM'),b()})}),test('backdrop appears behind the overlay',function(b){runAfterOpen(a,function(){styleZ=parseInt(window.getComputedStyle(a).zIndex,10),backdropStyleZ=parseInt(window.getComputedStyle(a.backdropElement).zIndex,10),assert.isTrue(styleZ>backdropStyleZ,'overlay has higher z-index than backdrop'),b()})}),test('backdrop is removed when overlay is closed',function(b){runAfterOpen(a,function(){runAfterClose(a,function(){assert.isFalse(a.backdropElement.opened,'backdrop is closed'),assert.isNotOk(a.backdropElement.parentNode,'backdrop is removed from the DOM'),assert.lengthOf(document.querySelectorAll('iron-overlay-backdrop'),0,'no backdrop elements on body'),b()})})}),test('backdrop is removed when the element is removed from DOM',function(b){runAfterOpen(a,function(){Polymer.dom(a).parentNode.removeChild(a),Polymer.dom.flush(),assert.isFalse(a.backdropElement.opened,'backdrop is closed'),assert.isNotOk(a.backdropElement.parentNode,'backdrop is removed from the DOM'),assert.lengthOf(document.querySelectorAll('iron-overlay-backdrop'),0,'no backdrop elements on body'),assert.isNotOk(a._manager.currentOverlay(),'currentOverlay ok'),b()})}),test('manager.getBackdrops() updated on opened changes',function(b){runAfterOpen(a,function(){assert.equal(Polymer.IronOverlayManager.getBackdrops().length,1,'overlay added to manager backdrops'),runAfterClose(a,function(){assert.equal(Polymer.IronOverlayManager.getBackdrops().length,0,'overlay removed from manager backdrops'),b()})})}),test('updating with-backdrop to false closes backdrop',function(b){runAfterOpen(a,function(){a.withBackdrop=!1,assert.isFalse(a.backdropElement.opened,'backdrop is closed'),assert.isNotObject(a.backdropElement.parentNode,'backdrop is removed from document'),b()})}),test('backdrop is removed when toggling overlay opened',function(b){a.open(),runAfterClose(a,function(){assert.isFalse(a.backdropElement.opened,'backdrop is closed'),assert.isNotOk(a.backdropElement.parentNode,'backdrop is removed from document'),b()})}),test('withBackdrop = false does not prevent click outside event',function(b){a.withBackdrop=!1,runAfterOpen(a,function(){a.addEventListener('iron-overlay-canceled',function(c){assert.isFalse(c.detail.defaultPrevented,'click event not prevented'),b()}),MockInteractions.tap(document.body)})})}),suite('multiple overlays',function(){var a,b;setup(function(){var c=fixture('multiple');a=c[0],b=c[1]}),test('new overlays appear on top',function(c){runAfterOpen(a,function(){runAfterOpen(b,function(){var d=parseInt(window.getComputedStyle(a).zIndex,10),e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isTrue(e>d,'overlay2 has higher z-index than overlay1'),c()})})}),test('ESC closes only the top overlay',function(c){runAfterOpen(a,function(){runAfterOpen(b,function(){MockInteractions.pressAndReleaseKeyOn(document,27),assert.isFalse(b.opened,'overlay2 was closed'),assert.isTrue(a.opened,'overlay1 is still opened'),c()})})}),test('close an overlay in proximity to another overlay',function(c){a.open(),a.close(),b.open(),runAfterClose(b,function(){c()})})}),suite('Manager overlays in sync',function(){var a,b,c;setup(function(){var d=fixture('multiple');a=d[0],b=d[1],c=Polymer.IronOverlayManager._overlays}),test('no duplicates after attached',function(d){a=document.createElement('test-overlay'),runAfterOpen(a,function(){assert.equal(c.length,1,'correct count after open and attached'),document.body.removeChild(a),d()}),document.body.appendChild(a)}),test('call open multiple times handled',function(d){a.open(),a.open(),runAfterOpen(a,function(){assert.equal(c.length,1,'1 overlay after open'),d()})}),test('close handled',function(d){runAfterOpen(a,function(){runAfterClose(a,function(){assert.equal(c.length,0,'0 overlays after close'),d()})})}),test('open/close brings overlay on top',function(d){a.open(),runAfterOpen(b,function(){assert.equal(c.indexOf(a),0,'overlay1 at index 0'),assert.equal(c.indexOf(b),1,'overlay2 at index 1'),a.close(),runAfterOpen(a,function(){assert.equal(c.indexOf(a),1,'overlay1 moved at index 1'),assert.isAbove(parseInt(a.style.zIndex),parseInt(b.style.zIndex),'overlay1 on top of overlay2'),d()})})})}),suite('z-ordering',function(){var a,b,c;setup(function(){var d=fixture('multiple');b=d[0],c=d[1],a=Polymer.IronOverlayManager._minimumZ}),teardown(function(){Polymer.IronOverlayManager._minimumZ=a}),test('default z-index is greater than 100',function(d){runAfterOpen(b,function(){var e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isTrue(100<e,'overlay1 z-index is <= 100'),d()})}),test('ensureMinimumZ() effects z-index',function(d){Polymer.IronOverlayManager.ensureMinimumZ(1e3),runAfterOpen(b,function(){var e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isTrue(1e3<e,'overlay1 z-index is <= 1000'),d()})}),test('ensureMinimumZ() never decreases the minimum z-index',function(d){Polymer.IronOverlayManager.ensureMinimumZ(1e3),Polymer.IronOverlayManager.ensureMinimumZ(500),runAfterOpen(b,function(){var e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isTrue(1e3<e,'overlay1 z-index is <= 1000'),d()})})}),suite('multiple overlays with backdrop',function(){var a,b,c;setup(function(){var d=fixture('multiple');a=d[0],b=d[1],c=d[2],a.withBackdrop=b.withBackdrop=c.withBackdrop=!0}),test('multiple overlays share the same backdrop',function(){assert.isTrue(a.backdropElement===b.backdropElement,'overlay1 and overlay2 have the same backdrop element'),assert.isTrue(a.backdropElement===c.backdropElement,'overlay1 and overlay3 have the same backdrop element')}),test('only one iron-overlay-backdrop in the DOM',function(d){a.opened=!0,b.opened=!0,runAfterOpen(c,function(){assert.lengthOf(document.querySelectorAll('iron-overlay-backdrop'),1,'only one backdrop element in the DOM'),d()})}),test('iron-overlay-backdrop is removed from the DOM when all overlays with backdrop are closed',function(d){a.opened=!0,b.opened=!0,runAfterOpen(c,function(){a.opened=b.opened=!1,runAfterClose(c,function(){assert.lengthOf(document.querySelectorAll('iron-overlay-backdrop'),0,'backdrop element removed from the DOM'),d()})})}),test('newest overlay appear on top',function(d){runAfterOpen(a,function(){runAfterOpen(b,function(){var e=parseInt(window.getComputedStyle(a).zIndex,10),g=parseInt(window.getComputedStyle(b).zIndex,10),h=parseInt(window.getComputedStyle(a.backdropElement).zIndex,10);assert.isTrue(g>e,'overlay2 has higher z-index than overlay1'),assert.isTrue(e>h,'overlay1 has higher z-index than backdrop'),d()})})}),test('click event handled only by top overlay',function(d){runAfterOpen(a,function(){runAfterOpen(b,function(){var e=Polymer.dom(b).querySelector('button');e.addEventListener('click',b.close.bind(b)),MockInteractions.tap(e),assert.isFalse(b.opened,'overlay2 closed'),assert.isTrue(a.opened,'overlay1 opened'),b.addEventListener('iron-overlay-closed',function(){assert.isTrue(a.opened,'overlay1 still opened'),d()})})})}),test('tap event handled only by top overlay',function(d){runAfterOpen(a,function(){runAfterOpen(b,function(){var e=Polymer.dom(b).querySelector('button');e.addEventListener('tap',b.close.bind(b)),MockInteractions.tap(e),assert.isFalse(b.opened,'overlay2 closed'),assert.isTrue(a.opened,'overlay1 opened'),b.addEventListener('iron-overlay-closed',function(){assert.isTrue(a.opened,'overlay1 still opened'),d()})})})}),test('updating with-backdrop updates z-index',function(d){runAfterOpen(a,function(){runAfterOpen(b,function(){a.withBackdrop=!1;var e=parseInt(window.getComputedStyle(a).zIndex,10),g=parseInt(window.getComputedStyle(b).zIndex,10),h=parseInt(window.getComputedStyle(a.backdropElement).zIndex,10);assert.isTrue(g>h,'overlay2 has higher z-index than backdrop'),assert.isTrue(e<h,'overlay1 has lower z-index than backdrop'),d()})})})}),suite('overlay in composed tree',function(){var a,b,c;setup(function(d){a=fixture('composed'),b=a.$.overlay,c=a.$.trigger,b.withBackdrop=!0,b.addEventListener('iron-overlay-opened',function(){d()}),MockInteractions.tap(c)}),test('click on overlay content does not close it',function(d){MockInteractions.tap(Polymer.dom(b).querySelector('button')),Polymer.Base.async(function(){assert.isTrue(b.opened,'overlay still opened'),d()},1)}),test('with-backdrop wraps the focus within the overlay',function(d){Polymer.Base.async(function(){var e=Polymer.dom(b).querySelectorAll('button');e[e.length-1].focus();var g=sinon.spy();document.addEventListener('keydown',g),MockInteractions.pressAndReleaseKeyOn(document,9),assert.equal(e[0],Polymer.IronOverlayManager.deepActiveElement,'focus wrapped to first focusable'),assert.isTrue(g.calledOnce,'keydown spy called'),assert.isTrue(g.getCall(0).args[0].defaultPrevented,'keydown default prevented'),MockInteractions.pressAndReleaseKeyOn(document,9,['shift']),assert.equal(e[e.length-1],Polymer.IronOverlayManager.deepActiveElement,'focus wrapped to last focusable'),assert.isTrue(g.calledTwice,'keydown spy called again'),assert.isTrue(g.getCall(1).args[0].defaultPrevented,'keydown default prevented again'),document.removeEventListener('keydown',g),d()},1)})}),suite('always-on-top',function(){var a,b;setup(function(){var c=fixture('multiple');a=c[0],b=c[1],a.alwaysOnTop=!0}),test('stays on top',function(c){runAfterOpen(a,function(){runAfterOpen(b,function(){var d=parseInt(window.getComputedStyle(a).zIndex,10),e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isAbove(d,e,'overlay1 on top'),assert.equal(Polymer.IronOverlayManager.currentOverlay(),a,'currentOverlay ok'),c()})})}),test('stays on top also if another overlay is with-backdrop',function(c){b.withBackdrop=!0,runAfterOpen(a,function(){runAfterOpen(b,function(){var d=parseInt(window.getComputedStyle(a).zIndex,10),e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isAbove(d,e,'overlay1 on top'),assert.equal(Polymer.IronOverlayManager.currentOverlay(),a,'currentOverlay ok'),c()})})}),test('last overlay with always-on-top wins',function(c){b.alwaysOnTop=!0,runAfterOpen(a,function(){runAfterOpen(b,function(){var d=parseInt(window.getComputedStyle(a).zIndex,10),e=parseInt(window.getComputedStyle(b).zIndex,10);assert.isAbove(e,d,'overlay2 on top'),assert.equal(Polymer.IronOverlayManager.currentOverlay(),b,'currentOverlay ok'),c()})})})}),suite('animations',function(){test('overlay animations correctly triggered',function(a){var b=fixture('basic');b.animated=!0,b.open(),b.addEventListener('simple-overlay-open-animation-start',function(){var c=document.elementFromPoint(window.innerWidth/2,window.innerHeight/2);assert.notEqual(c,b,'overlay should not be centered already'),a()})})}),suite('a11y',function(){test('overlay has aria-hidden=true when opened',function(){var a=fixture('basic');assert.equal(a.getAttribute('aria-hidden'),'true','overlay has aria-hidden="true"'),a.open(),assert.isFalse(a.hasAttribute('aria-hidden'),'overlay does not have aria-hidden attribute'),a.close(),assert.equal(a.getAttribute('aria-hidden'),'true','overlay has aria-hidden="true"')})});</script></body></html>